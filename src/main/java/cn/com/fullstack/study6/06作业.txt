可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
1 说说下面的几个方法，分别锁的是什么东西？

 public static synchronized void doIt(){xx};
 //锁的是全局实例的doIt()方法
 pubilc  syncronzied void doIt() {xxx)
 //锁的是当前实例的doI方法
 pubilc void doIt(){ syncronized(myobj) ....}
 //锁的是当前myobj对象doIt这个方法中的代码块

 2 说说为什么下面的代码是错误的
 public void doIt() { syncronized(new ObjA()) {xxxx}
 从语法上面来说是没有错误的，但是实际上sync同步块并没有生效。sync锁的要么是共同的一个实例，或者是一个公共的类。
 这样才有同步的效果。

 3 说说下面的代码为什么是错误的
 public void doIt() {synchrnized(myobj) { if(xxx) { myobjA.wait();}...}
 wait方法没有使用while循环体中。
 为什么要在循环中wait？有以下几个原因。
 1、一个对象锁可能用于保护多个状态变量，当它们都需要wait-notify操作时，如果不将wait放到while中就有问题。例如，某对象锁obj保护两种状态变量a和b，当a的条件断言不成立时发生了wait操作，当b的条件断言不成立时也发生了wait操作，两个线程被加入到obj对应的条件队列中，现在若改变状态变量a的某操作发生，在obj上调用了notifyAll操作，obj对应的条件队列里的所有线程均被唤醒，之前等待a的某个或几个线程去判断a的条件断言可能成立了，但b对应的条件断言肯定仍不成立，而此时等待b的线程也被唤醒了，所以需要循环判断b的条件断言是否满足，如果不满足，继续wait。
 2、多个线程wait的同一个状态的条件断言。如BlockingQueue场景下，当前队列是空的，多个线程要从里面取元素，于是都wait了。此时另一个线程往里面添加了一个元素，调用了notifyAll操作，唤醒了所有线程，但只有一个线程能拿到那个新加进来的元素，继续走下去，其它的仍需等待。
 3、虚假唤醒。在没有被通知、中断或超时的情况下，线程自动苏醒了。虽然这种情况在实践中很少发生，但是必须通过循环检测条件是否满足的方式来防止其发生，如果不满足该条件，则继续等待。

 4 将05作业-TestOnly.java 中的代码中的错误一一修订，并确保其永远执行成功



加分题
1 用Lock方式与ReadWriteLock方式 对第四题进行改进，并说明思路
2 用多线程方式实现第二课的第四题，其中计算线程数为8个，可能的思路：
       文件的总记录读取后分为8份，每个线程处理一份，所有线程都完成后，再累计汇总，输出结果
